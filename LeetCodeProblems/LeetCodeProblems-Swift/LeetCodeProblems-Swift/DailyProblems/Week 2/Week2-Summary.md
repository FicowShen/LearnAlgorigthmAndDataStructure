# 第二周总结


## 哈希表、映射、集合

### 哈希表
* 核心由一个哈希函数和存放key的哈希表构成
* 哈希函数计算的哈希值可能会出现哈希碰撞，解决哈希碰撞的常见方式是拉链法，在相同key的位置用链表存放哈希值相同的多个节点
* 插入、查询、删除操作的平均时间复杂度：O(1)，最坏（哈希碰撞、哈希表的key数组太小）：O(n)

### 映射（[Java Map](https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/util/Map.html)）
* 不一定基于哈希表来实现，可能基于二叉搜索树、红黑树、跳表实现等

### 集合（[Java Set](https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/util/Set.html)）
* 实现可能为多种，如：HashSet、TreeSet

### 阅读 [Java HashMap](https://hg.openjdk.java.net/jdk8/jdk8/jdk/file/687fd7c7986d/src/share/classes/java/util/HashMap.java)（主要是 putVal, getNode 方法），写一个关于 HashMap 的小总结：

#### putVal
1. 插入前，先检查哈希表的空间，初始化或者使长度翻倍；
2. 根据不同情况进行处理：
	- 如果尚未拉链，直接插入一个普通链表Node；
	- 如果已拉链：
		- 节点为 TreeNode(红黑树节点)，则创建并添加 TreeNode；
		- 在链表中找到了key相同的节点，更新该节点的值，然后调用事件勾子函数，并返回旧的值；
		- 没在链表中找到key相同的节点，添加一个普通Node，如果链表节点数达到阈值，把链表转为红黑树；最后，将用于检查并发修改的修改计数器加1，size 也加1并检查是否需要为哈希表扩容，然后调用事件勾子函数并返回 null；

#### getNode
1. 如果哈希表为空，或者根据哈希值对应的链表为空，直接返回 null；否则，开始查找；
2. 如果链表中的第一个节点的 key 匹配，返回第一个节点；否则，继续查找；
3. 如果第一个节点为红黑树节点，在红黑树中查找并返回结果；否则，在链表中顺序查找并返回结果；


## 树、二叉树、二叉搜索树

> 提高各种数据结构效率的方法：升维

### 树
* 链表 -> 树(多个next节点) -> 图(有环)

### 二叉树
* 二叉树的遍历方式：
	- 前序：根左右
	- 中序：左根右
	- 后序：左右根
	- 层序：广度优先搜索，一层一层地遍历

### 二叉搜索树
* 左子树**所有**的节点都小于根节点，右子树**所有**的节点都大于根节点。
* 中序遍历是升序
* 插入、查询、删除操作的平均时间复杂度：O(logn)
* 特殊情况会退化为一个链表，复杂度变为：O(n)


## 树的面试题解法一般都是递归，为什么？
树本身的定义就存在递归，所以递归解法也更适于遍历树。而且，树的子树就是一个更小规模的树，这与递归中的子问题概念完美契合。



## 堆和二叉堆、图

### 堆/优先队列
可以迅速找到一堆数中的最大或者最小值的数据结构，如：大顶堆、小顶堆
实现有很多种，最常见的堆：二叉堆、斐波那契堆
查找最值：O(1)，插入、删除：O(logn)，斐波那契堆可以达到 O(1)

### 二叉堆
性质：1.是一棵完全二叉树(只有叶子可能是不满的)； 2. 树中任意节点的值总是 >= 其子节点的值；
相对比较容易实现，一般通过数组实现

### 图
由点和边构成。
点(vertex)：入度和出度，边(edge)：有向和无向以及权重。
分类：无向无权图、有向无权图、无向有权图、有向有权图
表示方法：1.邻接矩阵 2.邻接表
常见的遍历方法（切记，用visited集合记录）：DFS、BFS







## 实战题目总结

* [有效的字母异位词](https://leetcode-cn.com/problems/valid-anagram/)
1. O(nlogn)，主要是排序。比较字符串长度、长度相等则比较排序后的字符串。
2. O(n)，遍历字符串。比较字符串长度、长度相等则遍历字符串a，同时用字典记录每个字符出现的次数；然后遍历字符串b，同时减去每个字符出现的次数，如果某个字母出现的次数小于0，说明不相等。

* [字母异位词分组](https://leetcode-cn.com/problems/group-anagrams/)
1. O(nklogk)，n 为字符串数量，k为字符串的最大长度。遍历所有字符串，将排序后的字符串作为字典的key，然后将排序前的字符串添加到key对应的value数组中，最后返回字典所有的values；
2. O(nk)，n 为字符串数量，k为字符串的最大长度，26个字母可以忽略。遍历所有字符串，对每个字符串进行遍历，将a-z和出现的次数拼装字符串作为字典的key，然后将字符串添加到key对应的value数组中，最后返回字典所有的values；

* [两数之和](https://leetcode-cn.com/problems/two-sum/)
O(n)，遍历数组。计算差值，然后在字典中查找。如果存在就返回字典中记录的值和当前下标，如果不存在，将当前值作为key，下标作为value存入字典。







